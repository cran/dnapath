<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Reactome pathways</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>This vignette shows how the package datasets were created. The package data includes a list of cancer-related Reactome pathways, <code>p53_pathways</code>, and an example gene expression dataset, <code>glioma</code>. These are provided to be used in examples and for illustrative purposes.</p>

<h1>Reactome pathways</h1>

<p>A list of Reaectome pathways is provided for Homo sapiens (human). This list was initialized using the <code>dnapath::get_reactome_pathways()</code> function.</p>

<pre><code class="r">pathway_list &lt;- dnapath::get_reactome_pathways(&quot;human&quot;)
</code></pre>

<pre><code>## Obtaining reactome pathway information for species: Homo sapiens 
## Combining pathways that have greater than 90 % overlap.
</code></pre>

<p>This list contains the gene sets for 885 pathways. Here are the first two pathways:</p>

<pre><code class="r">pathway_list[1:2]
</code></pre>

<pre><code>## $`Purine salvage`
##  [1] &quot;100&quot;    &quot;132&quot;    &quot;161823&quot; &quot;1633&quot;   &quot;1716&quot;   &quot;270&quot;    &quot;271&quot;    &quot;272&quot;   
##  [9] &quot;2766&quot;   &quot;3251&quot;   &quot;353&quot;    &quot;4860&quot;   &quot;51292&quot; 
## 
## $`Nucleotide salvage`
##  [1] &quot;100&quot;    &quot;132&quot;    &quot;151531&quot; &quot;161823&quot; &quot;1633&quot;   &quot;1716&quot;   &quot;1890&quot;   &quot;270&quot;   
##  [9] &quot;271&quot;    &quot;272&quot;    &quot;2766&quot;   &quot;3251&quot;   &quot;353&quot;    &quot;4860&quot;   &quot;51292&quot;  &quot;54963&quot; 
## [17] &quot;7083&quot;   &quot;7084&quot;   &quot;7371&quot;   &quot;7378&quot;   &quot;8226&quot;   &quot;83549&quot;  &quot;978&quot;
</code></pre>

<p>The list names correspond to the Reactome pathway name. Each pathway provides the entrezgene IDs of all genes in that pathway. For example, from the output above, we see that the first pathway in the list is the &ldquo;purine salvage&rdquo; pathway, and it contains the genes: 100, 132, 161823, etc.</p>

<p>In practice, all of these pathways can be used in the <code>dnapath()</code> analysis. However, in some studies we may only be interested in a subset of this list. For example, if we are studying a cancer-related gene expression dataset, we may have a specific interest in cancer-related pathways. There are two ways to obtain a subset from the pathway list: (1) using the pathway names or (2) using the pathway genes. These two approaches are demonstrated in turn.</p>

<h2>Subsetting pathways using pathway names</h2>

<p>Suppose we are interested in pathways that are related to &ldquo;p53&rdquo; or &ldquo;pi3k&rdquo; regulatory processes (these are known cancer-related pathways). One option is to subset pathways based on whether or not the pathway names include these keywords. The <code>grep()</code> function is used to do this:</p>

<pre><code class="r"># Obtain index of pathways containing &quot;p53&quot; or &quot;pi3k&quot; in their name.
index_pathways &lt;- grep(&quot;((p53)|(pi3k))&quot;, names(pathway_list),
                       ignore.case = TRUE)
</code></pre>

<p><code>grep</code> uses the regular expression &ldquo;((p53)|(pi3k))&rdquo;, which says to identify all pathway names that include the phrase &ldquo;p53&rdquo; or &ldquo;pi3k&rdquo;. However, we don&#39;t want to leave out pathways that use capital &ldquo;P53&rdquo; or &ldquo;PI3K&rdquo;, so we set <code>ignore.case = TRUE</code> to ignore the case of the pathway names.</p>

<pre><code class="r"># Subset onto the &quot;p53&quot; and &quot;pi3k&quot; pathways.
cancer_pathways &lt;- pathway_list[index_pathways]
cancer_pathways[1:3] # Print out the first three
</code></pre>

<pre><code>## $`CD28 dependent PI3K/Akt signaling`
##  [1] &quot;10000&quot;  &quot;117145&quot; &quot;1326&quot;   &quot;207&quot;    &quot;208&quot;    &quot;2475&quot;   &quot;253260&quot; &quot;2534&quot;  
##  [9] &quot;3932&quot;   &quot;5170&quot;   &quot;5290&quot;   &quot;5295&quot;   &quot;5296&quot;   &quot;55615&quot;  &quot;57761&quot;  &quot;64223&quot; 
## [17] &quot;79109&quot;  &quot;8503&quot;   &quot;9020&quot;   &quot;940&quot;    &quot;941&quot;    &quot;942&quot;   
## 
## $`G beta:gamma signalling through PI3Kgamma`
##  [1] &quot;10000&quot;  &quot;10681&quot;  &quot;146850&quot; &quot;207&quot;    &quot;208&quot;    &quot;23533&quot;  &quot;2782&quot;   &quot;2783&quot;  
##  [9] &quot;2784&quot;   &quot;2785&quot;   &quot;2786&quot;   &quot;2787&quot;   &quot;2788&quot;   &quot;2790&quot;   &quot;2791&quot;   &quot;2792&quot;  
## [17] &quot;2793&quot;   &quot;387&quot;    &quot;5170&quot;   &quot;51764&quot;  &quot;5294&quot;   &quot;54331&quot;  &quot;55970&quot;  &quot;59345&quot; 
## [25] &quot;94235&quot; 
## 
## $`Regulation of TP53 Degradation (See also: Regulation of TP53 Expression and Degradation)`
##  [1] &quot;10000&quot;  &quot;1017&quot;   &quot;1029&quot;   &quot;11200&quot;  &quot;117584&quot; &quot;1616&quot;   &quot;207&quot;    &quot;208&quot;   
##  [9] &quot;2475&quot;   &quot;253260&quot; &quot;4193&quot;   &quot;4194&quot;   &quot;472&quot;    &quot;51230&quot;  &quot;5170&quot;   &quot;5515&quot;  
## [17] &quot;5516&quot;   &quot;5518&quot;   &quot;5519&quot;   &quot;5527&quot;   &quot;55615&quot;  &quot;6233&quot;   &quot;64223&quot;  &quot;6446&quot;  
## [25] &quot;7157&quot;   &quot;7311&quot;   &quot;7314&quot;   &quot;7316&quot;   &quot;7874&quot;   &quot;79109&quot;  &quot;80196&quot;  &quot;890&quot;   
## [33] &quot;8900&quot;   &quot;900&quot;    &quot;9099&quot;   &quot;983&quot;    &quot;639&quot;
</code></pre>

<p>Subsetting on these cancer-related pathways results in 19 pathways. </p>

<p>In general, the pathway list obtained from the <code>dnapath::get_reactome_pathways()</code> function can be subset based on the pathway names, as illustrated in this example. Here, we focused on cancer pathways, but the regular expression &ldquo;((p53)|(pi3k))&rdquo; can be replaced to search for any desired pathways. To learn more about the <code>grep()</code> function and regular expression, see <a href="https://bookdown.org/rdpeng/rprogdatascience/regular-expressions.html">chapter 17</a> of R Programming for Data Science by Roger Peng.</p>

<h2>Subsetting pathways using genes</h2>

<p>As in the previous example, suppose we are interested in pathways that are related to &ldquo;p53&rdquo; or &ldquo;pi3k&rdquo;. However, this time we want to identify <em>all</em> pathways that involve the genes, not just pathways that are named after them. (Note that some pathways may contain the p53 gene but not have &ldquo;p53&rdquo; in its name.)</p>

<p>Since the pathway list uses entrezgene IDs, the first step is to find the entrezgene ID for each gene of interest. The ID for P53 is <a href="https://www.ncbi.nlm.nih.gov/gene?cmd=Retrieve&amp;dopt=full_report&amp;list_uids=7157">7157</a>. PI3K actually refers to a family of enzymes; one class of genes in this family include PIK3CA, PIK3CB, PIK3CD, and PIK3CG, which have the entrezgene IDs
<a href="https://www.ncbi.nlm.nih.gov/gene?cmd=Retrieve&amp;dopt=full_report&amp;list_uids=5290">5290</a>, 
<a href="https://www.ncbi.nlm.nih.gov/gene?cmd=Retrieve&amp;dopt=full_report&amp;list_uids=5291">5291</a>,
<a href="https://www.ncbi.nlm.nih.gov/gene?cmd=Retrieve&amp;dopt=full_report&amp;list_uids=5293">5293</a>, and
<a href="https://www.ncbi.nlm.nih.gov/gene?cmd=Retrieve&amp;dopt=full_report&amp;list_uids=5294">5294</a>.</p>

<pre><code class="r"># Make a vector of all entrezgene IDs that we are interested in.
genes_of_interest &lt;- c(7157, 5290, 5291, 5293, 5294)
# Obtain index of pathways containing any genes of interest.
index_pathways &lt;- which(sapply(pathway_list, function(pathway) {
  any(genes_of_interest %in% pathway)
}))
</code></pre>

<p>The <code>sapply()</code> function is used to loop over each pathway in the pathway list, and for each we determine if any of the genes of interest are in the pathway&#39;s gene set. We end up with a set of indices identifying which pathways contain at least one of the five targeted genes.</p>

<pre><code class="r"># Subset onto pathways containing p53 gene or pi3k family of genes.
cancer_pathways &lt;- pathway_list[index_pathways]
cancer_pathways[1:3] # Print out the first three
</code></pre>

<pre><code>## $`Activation of BH3-only proteins`
##  [1] &quot;10000&quot;  &quot;10018&quot;  &quot;10971&quot;  &quot;140735&quot; &quot;1869&quot;   &quot;207&quot;    &quot;208&quot;    &quot;23368&quot; 
##  [9] &quot;27113&quot;  &quot;2810&quot;   &quot;5366&quot;   &quot;5533&quot;   &quot;5534&quot;   &quot;5599&quot;   &quot;572&quot;    &quot;572&quot;   
## [17] &quot;596&quot;    &quot;637&quot;    &quot;7027&quot;   &quot;7029&quot;   &quot;7157&quot;   &quot;7159&quot;   &quot;7161&quot;   &quot;7529&quot;  
## [25] &quot;7531&quot;   &quot;7532&quot;   &quot;7533&quot;   &quot;7534&quot;   &quot;8626&quot;   &quot;8655&quot;   &quot;90427&quot; 
## 
## $`Signaling by ERBB2`
##  [1] &quot;10000&quot;  &quot;10193&quot;  &quot;10273&quot;  &quot;10718&quot;  &quot;10718&quot;  &quot;11140&quot;  &quot;145957&quot; &quot;145957&quot;
##  [9] &quot;1729&quot;   &quot;1839&quot;   &quot;1839&quot;   &quot;1950&quot;   &quot;1950&quot;   &quot;1956&quot;   &quot;1956&quot;   &quot;2064&quot;  
## [17] &quot;2064&quot;   &quot;2065&quot;   &quot;2065&quot;   &quot;2066&quot;   &quot;2066&quot;   &quot;2069&quot;   &quot;2069&quot;   &quot;207&quot;   
## [25] &quot;208&quot;    &quot;2534&quot;   &quot;2549&quot;   &quot;26469&quot;  &quot;2885&quot;   &quot;2885&quot;   &quot;2886&quot;   &quot;3084&quot;  
## [33] &quot;3084&quot;   &quot;3265&quot;   &quot;3265&quot;   &quot;3320&quot;   &quot;3845&quot;   &quot;3845&quot;   &quot;387&quot;    &quot;4145&quot;  
## [41] &quot;4893&quot;   &quot;4893&quot;   &quot;51072&quot;  &quot;5290&quot;   &quot;5295&quot;   &quot;5335&quot;   &quot;5578&quot;   &quot;5580&quot;  
## [49] &quot;5581&quot;   &quot;55914&quot;  &quot;5753&quot;   &quot;5782&quot;   &quot;5782&quot;   &quot;6233&quot;   &quot;6464&quot;   &quot;6464&quot;  
## [57] &quot;6654&quot;   &quot;6654&quot;   &quot;6714&quot;   &quot;685&quot;    &quot;685&quot;    &quot;7311&quot;   &quot;7314&quot;   &quot;7316&quot;  
## [65] &quot;7525&quot;   &quot;8065&quot;   &quot;9101&quot;   &quot;9542&quot;   &quot;9542&quot;  
## 
## $`CD28 co-stimulation`
##  [1] &quot;10000&quot;  &quot;117145&quot; &quot;1326&quot;   &quot;207&quot;    &quot;208&quot;    &quot;2475&quot;   &quot;253260&quot; &quot;2534&quot;  
##  [9] &quot;2885&quot;   &quot;3932&quot;   &quot;4067&quot;   &quot;5058&quot;   &quot;5062&quot;   &quot;5063&quot;   &quot;5170&quot;   &quot;5290&quot;  
## [17] &quot;5295&quot;   &quot;5296&quot;   &quot;55615&quot;  &quot;57761&quot;  &quot;5879&quot;   &quot;64223&quot;  &quot;6714&quot;   &quot;7409&quot;  
## [25] &quot;7525&quot;   &quot;79109&quot;  &quot;8503&quot;   &quot;9020&quot;   &quot;940&quot;    &quot;9402&quot;   &quot;941&quot;    &quot;942&quot;   
## [33] &quot;998&quot;
</code></pre>

<p>Subsetting results in 80 pathways that contain at least one of the five cancer-related genes of interest. In general, any set of entrezgene IDs can be used to subset the pathways obtained from the <code>dnapath::get_reactome_pathways()</code> function, as illustrated in this example. </p>

<h2><code>p53_pathways</code> data</h2>

<p>The <code>dnapath</code> package provides an example pathway list named <code>p53_pathways</code>. This is a small list provided for illustrative purposes and for use in examples. It includes T53 Reactome pathways, which was created using the steps described previously.</p>

<pre><code class="r"># Obtain index of pathways containing &quot;p53&quot; in their name.
index_pathways &lt;- grep(&quot;(p53)&quot;, names(pathway_list),ignore.case = TRUE)
p53_pathways &lt;- pathway_list[index_pathways]
</code></pre>

<p>The dataset was compressed and saved for the package using the code:</p>

<pre><code class="R"># Not run: Only for building the package.
usethis::use_data(p53_pathways)
tools::resaveRdaFiles(file.path(&quot;data&quot;), compress = &quot;auto&quot;)
tools::checkRdaFiles(file.path(&quot;data&quot;))
</code></pre>

<h1>Gene expression example</h1>

<p>A small gene expression dataset is provided in <code>dnapath</code>. This example data is a Mesothelioma dataset containing gene expression and clinical data that were generated by <a href="https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga">The Cancer Genome Atlas</a> (TCGA) and is downloaded using the [LinkedOmics] portal(<a href="http://www.linkedomics.org/data_download/TCGA-GBMLGG/">http://www.linkedomics.org/data_download/TCGA-GBMLGG/</a>). </p>

<h2><code>meso</code> data</h2>

<p>The first step is to download and process the clinical and gene expression dataset from LinkedOmics.</p>

<pre><code class="r">file_clinical &lt;- paste0(&quot;http://linkedomics.org/data_download/TCGA-MESO/Human__&quot;,
                        &quot;TCGA_MESO__MS__Clinical__Clinical__01_28_2016__BI__&quot;,
                        &quot;Clinical__Firehose.tsi&quot;)
file_rnaseq &lt;- paste0(&quot;http://linkedomics.org/data_download/TCGA-MESO/Human__&quot;,
                      &quot;TCGA_MESO__UNC__RNAseq__HiSeq_RNA__01_28_2016__BI__Gene&quot;,
                      &quot;__Firehose_RSEM_log2.cct.gz&quot;)

clinical &lt;- readr::read_tsv(file_clinical)
rnaseq &lt;- readr::read_tsv(file_rnaseq)
</code></pre>

<h3>Clinical dataset</h3>

<p>The differential network analysis performed using <code>dnapath()</code> compares the gene-gene association structure between two groups (populations). In the Mesothelioma dataset, the clinical data can be used to identify two subgroups of interest. In this example dataset, the tumor stage (classified as stage i, ii, iii, or iv) will be used to partition the data. In practice, <code>dnapath()</code> could be used make pair-wise comparisons across these tumor stages, or perhaps some stages can be combined together. But for the purpose of creating a small, example dataset, we will only look at tumor stages ii and iv.</p>

<p>The first step is to process the downloaded data so that it contains one column of sample IDs and one column of tumor stage. </p>

<pre><code class="r"># First, we can glimpse at the raw data to see how it is structured.
clinical[1:5, 1:3]
</code></pre>

<pre><code>## # A tibble: 5 × 3
##   attrib_name       TCGA.3H.AB3O TCGA.3H.AB3S
##   &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;       
## 1 years_to_birth    58           69          
## 2 pathologic_stage  stageiii     stageii     
## 3 pathology_T_stage t3           t2          
## 4 pathology_N_stage n0           n0          
## 5 pathology_M_stage m0           m0
</code></pre>

<pre><code class="r"># The columns contain samples, and rows contain different variables
# We want the transpose of this.
variable_names &lt;- clinical$attrib_name # Store the variable names.

# Transpose the matrix so that columns correspond to variables.
clinical &lt;- t(clinical[, -1]) # Don&#39;t include the &quot;attrib_name&quot; column as a row.
colnames(clinical) &lt;- variable_names # Rename columns using variable names.

# Glimpse at the transposed dataset:
clinical[1:4, 1:4]
</code></pre>

<pre><code>##              years_to_birth pathologic_stage pathology_T_stage
## TCGA.3H.AB3O &quot;58&quot;           &quot;stageiii&quot;       &quot;t3&quot;             
## TCGA.3H.AB3S &quot;69&quot;           &quot;stageii&quot;        &quot;t2&quot;             
## TCGA.3U.A98E &quot;71&quot;           &quot;stageiv&quot;        &quot;t4&quot;             
## TCGA.3U.A98G &quot;71&quot;           &quot;stageiv&quot;        &quot;t4&quot;             
##              pathology_N_stage
## TCGA.3H.AB3O &quot;n0&quot;             
## TCGA.3H.AB3S &quot;n0&quot;             
## TCGA.3U.A98E &quot;n2&quot;             
## TCGA.3U.A98G &quot;n0&quot;
</code></pre>

<pre><code class="r"># Now that the rows correspond to subjects and columns to variables,
# the next step is to add a new column that contains the sample IDs. 

clinical &lt;- cbind(ID = rownames(clinical), clinical)
rownames(clinical) &lt;- NULL # Remove the row names.

# Glimpse at the data.
clinical[1:4, 1:4]
</code></pre>

<pre><code>##      ID             years_to_birth pathologic_stage pathology_T_stage
## [1,] &quot;TCGA.3H.AB3O&quot; &quot;58&quot;           &quot;stageiii&quot;       &quot;t3&quot;             
## [2,] &quot;TCGA.3H.AB3S&quot; &quot;69&quot;           &quot;stageii&quot;        &quot;t2&quot;             
## [3,] &quot;TCGA.3U.A98E&quot; &quot;71&quot;           &quot;stageiv&quot;        &quot;t4&quot;             
## [4,] &quot;TCGA.3U.A98G&quot; &quot;71&quot;           &quot;stageiv&quot;        &quot;t4&quot;
</code></pre>

<pre><code class="r"># For the example dataset, we are only interested in ID and tumor stage.
clinical &lt;- clinical[, c(&quot;ID&quot;, &quot;pathologic_stage&quot;)]
# The two groups that will be compared are stage 2 and stage 4.
# Subset rows onto those that have stage 2 or stage 4.
clinical &lt;- clinical[clinical[, &quot;pathologic_stage&quot;] %in% c(&quot;stageii&quot;, &quot;stageiv&quot;), ]
clinical[1:5, ]
</code></pre>

<pre><code>##      ID             pathologic_stage
## [1,] &quot;TCGA.3H.AB3S&quot; &quot;stageii&quot;       
## [2,] &quot;TCGA.3U.A98E&quot; &quot;stageiv&quot;       
## [3,] &quot;TCGA.3U.A98G&quot; &quot;stageiv&quot;       
## [4,] &quot;TCGA.SC.AA5Z&quot; &quot;stageiv&quot;       
## [5,] &quot;TCGA.UT.A88D&quot; &quot;stageii&quot;
</code></pre>

<pre><code class="r"># We are left with only stage 2 and stage 4 samples:
table(clinical[, 2])
</code></pre>

<pre><code>## 
## stageii stageiv 
##      16      16
</code></pre>

<p>The final dataset contains 16 samples for group 1 (tumor stage ii) and 16 samples for group 2 (tumor stage iv). Note that the groups don&#39;t need equal sample sizes, but they happen to be equal in these data.</p>

<h3>RNA-seq dataset</h3>

<p>The second step is to process the gene expression dataset. The LinkedOmics portal provides normalized counts from the RNA-seq experiments (the data are not raw reads, which must be aligned and annotated in order to obtain gene expression counts). For the purpose of creating a small example dataset, these data will be subset onto the 32 samples obtained in the previous section, and onto the 160 genes in the <code>cancer_pathway</code> list.</p>

<pre><code class="r"># First, we can glimps at the raw data to see how it is structured.
rnaseq[1:5, 1:5]
</code></pre>

<pre><code>## # A tibble: 5 × 5
##   attrib_name TCGA.3H.AB3K TCGA.3H.AB3L TCGA.3H.AB3M TCGA.3H.AB3O
##   &lt;chr&gt;              &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;
## 1 A1BG               6.25          5.02        8.02          6.57
## 2 A1CF               0.687         0           0.462         0   
## 3 A2BP1              6.21          3.74        6.92          1.30
## 4 A2LD1              5.26          5.70        7.49          7.03
## 5 A2ML1              0.687         0           0             0
</code></pre>

<pre><code class="r"># As with the clinical data, we need to transpose the raw data so that
# samples are in the rows.
gene_symbols &lt;- rnaseq$attrib_name # Store the gene names

rnaseq &lt;- t(rnaseq[, -1])
colnames(rnaseq) &lt;- gene_symbols

rnaseq[1:5, 1:5]
</code></pre>

<pre><code>##                A1BG   A1CF  A2BP1  A2LD1  A2ML1
## TCGA.3H.AB3K 6.2508 0.6869 6.2128 5.2615 0.6869
## TCGA.3H.AB3L 5.0232 0.0000 3.7424 5.6967 0.0000
## TCGA.3H.AB3M 8.0151 0.4622 6.9154 7.4918 0.0000
## TCGA.3H.AB3O 6.5719 0.0000 1.2995 7.0304 0.0000
## TCGA.3H.AB3S 5.2770 0.0000 6.7363 7.0906 0.0000
</code></pre>

<pre><code class="r"># Check if all 32 clinical samples contain gene expression data.
all(clinical[, &quot;ID&quot;] %in% rownames(rnaseq))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r"># Subset the rnaseq data onto those in the clinical data
rnaseq &lt;- rnaseq[rownames(rnaseq) %in% clinical[, &quot;ID&quot;], ]

# Finally, we must make sure the two dataset are aligned.
# There are many ways to do this, here is one:
#   For each ID in the clinical dataset, find the corresponding row in rnaseq.
#   The rows are then reordered to match the IDs in clinical.
rnaseq &lt;- rnaseq[sapply(clinical[, &quot;ID&quot;], 
                        function(ID) which(rownames(rnaseq) == ID)), ]

# Check that the IDs match:
all(rownames(rnaseq) == clinical[, &quot;ID&quot;])
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">rnaseq[1:5, 1:5]
</code></pre>

<pre><code>##                A1BG   A1CF  A2BP1  A2LD1 A2ML1
## TCGA.3H.AB3S 5.2770 0.0000 6.7363 7.0906     0
## TCGA.3U.A98E 4.1398 0.0000 6.0186 5.8955     0
## TCGA.3U.A98G 7.9146 0.0000 2.7608 6.8913     0
## TCGA.SC.AA5Z 5.8400 0.0000 7.3606 5.7489     0
## TCGA.UT.A88D 6.1513 0.6561 4.2798 5.1120     0
</code></pre>

<p>The final step of processing the gene expression data is to subset the columns to the genes contained in the <code>cancer_pathway</code> list. However, the raw data provide gene symbols rather than entrezgene IDs (which the Reactome pathways use). So, we must either relabel the gene symbols in the <code>rnaseq</code> dataset to entrezgene IDs, or relabel the entrezgene IDs in <code>cancer_pathway</code> to contain gene symbols. Either of these operations can be easily carried out using the <code>symbol_to_entrez()</code>, <code>entrez_to_symbol()</code>, and <code>rename_genes()</code> functions provided in the package. These two approaches are briefly demonstrated next.</p>

<blockquote>
<p><strong>Note:</strong> Internet connection is required to connect to biomaRt, which the <code>entrez_to_symbol</code> and <code>symbol_to_entrez</code> methods use to map entrezgene IDs and gene symbols. The <code>dir_save</code> argument can be set when running these to save the ID mapping obtained from biomaRt in the specified directory. This way, the mapping can be obtained once (using the internet connection) and accessed from memory in all future calls of these functions. The temporary directory <code>tempdir()</code> is used in this example.</p>
</blockquote>

<p>First, we show how to convert gene symbols in the gene expression dataset to entrezgene IDs.</p>

<pre><code class="r"># Convert gene symbols -&gt; entrezgene IDs
gene_symbols &lt;- colnames(rnaseq) # Extract the gene symbols to relabel.
gene_mat &lt;- symbol_to_entrez(gene_symbols, &quot;human&quot;,
                             dir_save = tempdir()) # Obtain mapping.
</code></pre>

<pre><code>##  - loading gene info from /var/folders/vb/115zgf4x28vf40dccy9mj5hw0000gn/T//RtmpVwQnTV/entrez_to_hsapiens.rds
</code></pre>

<pre><code class="r">gene_mat[1:5, ]
</code></pre>

<pre><code>##   hgnc_symbol entrezgene_id
## 1        A1BG             1
## 2        A1CF         29974
## 3       A2BP1            -1
## 4       A2LD1            -1
## 5       A2ML1        144568
</code></pre>

<pre><code class="r"># The rename_genes() method is a multipurpose function that can be used to rename 
# the genes in a vector (the current case), a pathway list, or the &#39;dnapath_list&#39;
# object that is returned from dnapath() after performing the differential
# network analysis.
gene_entrez &lt;- rename_genes(gene_symbols, gene_mat) # Rename the symbols.
colnames(rnaseq) &lt;- gene_entrez # Update the columns using the entrezgene IDs.
rnaseq[1:5, 1:5] # Columns now contain entrezgene IDs
</code></pre>

<pre><code>##                   1  29974     -1     -1 144568
## TCGA.3H.AB3S 5.2770 0.0000 6.7363 7.0906      0
## TCGA.3U.A98E 4.1398 0.0000 6.0186 5.8955      0
## TCGA.3U.A98G 7.9146 0.0000 2.7608 6.8913      0
## TCGA.SC.AA5Z 5.8400 0.0000 7.3606 5.7489      0
## TCGA.UT.A88D 6.1513 0.6561 4.2798 5.1120      0
</code></pre>

<p>This is the approach used to create the <code>meso</code> data that is provided in this package. In general, it is advised to use entrezgene IDs throughout the analysis pipeline, and <strong>only convert to symbols at the very end</strong>. Entrezgene IDs are unique identifiers for each gene, whereas gene symbols can sometimes be ambiguous. This ambiguity can lead to information loss if used early on the analysis. For example, notice the third column in above output, the &ldquo;A2BP1&rdquo; gene, was not mapped to an entrezgene ID. This is because &ldquo;A2BP1&rdquo; is an alias for the RBFOX1 gene. The <code>symbol_to_entrez()</code> function obtains a mapping for RBFOX1 but not for the alias A2BP1. Because an entrezgene ID was not identified for A2BP1, it will not be identified in any of the pathways during the differential network analysis. </p>

<p>Gene symbols should only be considerd at the end of the analysis. It can be conventient to rename the IDs into symbols, since symbols are more recognizable for viewing and interpreting the results. </p>

<p><strong>Important note:</strong> In the Mesothelioma dataset, we are utilizing summarized gene expression counts as opposed to raw RNA-sequencing reads. If the raw reads are unavailable, then the user may not be able to control whether or not the genes are entrezgene IDs or gene symbols. In this case, we must be aware of the limitations and take caution if many gene symbols fail to map to entrezgene IDs. However, if raw reads are available, then it is recommended to align and annotate the reads using entrezgene IDs when obtaining the expression counts.</p>

<p>To finish the processing, the columns of <code>rnaseq</code> are subset onto the genes in <code>p53_pathways</code>.</p>

<pre><code class="r"># Subset the columns onto only those genes contained in &#39;p53_pathways&#39;
index_genes &lt;- which(colnames(rnaseq) %in% get_genes(p53_pathways))
rnaseq &lt;- rnaseq[, index_genes]
dim(rnaseq) # 32 samples with 150 genes.
</code></pre>

<pre><code>## [1]  32 148
</code></pre>

<p>For completeness, we will show how to convert the entrezgene IDs in the pathway list into gene symbols.</p>

<pre><code class="r"># Convert entrezgene IDs -&gt; gene symbols
gene_entrez &lt;- get_genes(p53_pathways) # Extract genes from pathway list.
gene_mat &lt;- entrez_to_symbol(gene_entrez, &quot;human&quot;, 
                             dir_save = tempdir()) # Obtain mapping.
</code></pre>

<pre><code>##  - loading gene info from /var/folders/vb/115zgf4x28vf40dccy9mj5hw0000gn/T//RtmpVwQnTV/entrez_to_hsapiens.rds
</code></pre>

<pre><code class="r">gene_mat[1:5, ]
</code></pre>

<pre><code>##   entrezgene_id hgnc_symbol
## 1         10000        AKT3
## 2          1017        CDK2
## 3          1029      CDKN2A
## 4         11200       CHEK2
## 5        117584        RFFL
</code></pre>

<pre><code class="r"># Convert the entrezgene IDs into gene symbols in the pathway list.
new_pathway_list &lt;- rename_genes(p53_pathways, gene_mat) 
new_pathway_list[1:2] # Print the first two pathways.
</code></pre>

<pre><code>## $`Regulation of TP53 Degradation (See also: Regulation of TP53 Expression and Degradation)`
##  [1] &quot;AKT3&quot;    &quot;CDK2&quot;    &quot;CDKN2A&quot;  &quot;CHEK2&quot;   &quot;RFFL&quot;    &quot;DAXX&quot;    &quot;AKT1&quot;   
##  [8] &quot;AKT2&quot;    &quot;MTOR&quot;    &quot;RICTOR&quot;  &quot;MDM2&quot;    &quot;MDM4&quot;    &quot;ATM&quot;     &quot;PHF20&quot;  
## [15] &quot;PDPK1&quot;   &quot;PPP2CA&quot;  &quot;PPP2CB&quot;  &quot;PPP2R1A&quot; &quot;PPP2R1B&quot; &quot;PPP2R5C&quot; &quot;PRR5&quot;   
## [22] &quot;RPS27A&quot;  &quot;MLST8&quot;   &quot;SGK1&quot;    &quot;TP53&quot;    &quot;UBA52&quot;   &quot;UBB&quot;     &quot;UBC&quot;    
## [29] &quot;USP7&quot;    &quot;MAPKAP1&quot; &quot;RNF34&quot;   &quot;CCNA2&quot;   &quot;CCNA1&quot;   &quot;CCNG1&quot;   &quot;USP2&quot;   
## [36] &quot;CDK1&quot;    &quot;PRDM1&quot;  
## 
## $`Regulation of TP53 Activity through Acetylation`
##  [1] &quot;AKT3&quot;    &quot;CHD3&quot;    &quot;CHD4&quot;    &quot;EP300&quot;   &quot;AKT1&quot;    &quot;AKT2&quot;    &quot;BRD1&quot;   
##  [8] &quot;BRPF3&quot;   &quot;BRD7&quot;    &quot;HDAC1&quot;   &quot;HDAC2&quot;   &quot;ING2&quot;    &quot;PIN1&quot;    &quot;PIP4K2A&quot;
## [15] &quot;MBD3&quot;    &quot;PML&quot;     &quot;GATAD2A&quot; &quot;MAP2K6&quot;  &quot;GATAD2B&quot; &quot;RBBP4&quot;   &quot;RBBP7&quot;  
## [22] &quot;MEAF6&quot;   &quot;TP53&quot;    &quot;BRPF1&quot;   &quot;PIP4K2C&quot; &quot;KAT6A&quot;   &quot;PIP4K2B&quot; &quot;ING5&quot;   
## [29] &quot;PIP4P1&quot;  &quot;MTA2&quot;
</code></pre>

<h3>Finalizing</h3>

<p>The <code>dnapath()</code> function requires either a list of two gene expression datasets (each corresponding to a different group), or a single gene expression data and a &#39;group&#39; vector that indicates which rows belong to which group. The <code>meso</code> data is formatted using the second option. The current <code>rnaseq</code> dataset that we have processed contains samples from both groups; the group information can be obtained from the <code>clinical</code> dataset. These two pieces of information can be conveniently stored as a list.</p>

<pre><code class="r">meso &lt;- list(gene_expression = rnaseq,
             groups = clinical[, &quot;pathologic_stage&quot;])
</code></pre>

<p>The list was compressed and saved for the package using the code:</p>

<pre><code class="R"># Not run: Only for building the package.
usethis::use_data(meso)
tools::resaveRdaFiles(file.path(&quot;data&quot;), compress = &quot;auto&quot;)
tools::checkRdaFiles(file.path(&quot;data&quot;))
</code></pre>

<h1>biomaRt</h1>

<p>The <code>biomaRt</code> package is used to link gene symbols with entrezgene IDs. The <code>entrez_to_symbol()</code> and <code>symbol_to_entrez()</code> functions require an internet connection to connect with the biomaRt database.</p>

<p>This package contains an instance of the mapping between HGNC gene symbols and entregene IDs, which will be used if internet access is not available or if the <code>biomaRt</code> package is not installed. However, this dataset will not be applicable to species other than <em>hsapiens</em> and may not contain the most up-to-date mapping. A warning is given when it is used.</p>

<pre><code class="R"># Not run: Internet access and `biomaRt` package is required.
mart &lt;- biomaRt::useMart(biomart = &quot;ensembl&quot;, 
                         dataset = &quot;hsapiens_gene_ensembl&quot;)

biomart_hsapiens &lt;- biomaRt::getBM(attributes = c(&quot;entrezgene_id&quot;, &quot;hgnc_symbol&quot;),
                                   mart = mart)

library(dplyr) # For pipe operator &quot;%&gt;%&quot;.
biomart_hsapiens %&gt;%
  dplyr::filter(!is.na(entrezgene_id)) %&gt;%
  dplyr::group_by(entrezgene_id) %&gt;%
  dplyr::summarise(across(everything(), dplyr::first)) -&gt;
  biomart_hsapiens
</code></pre>

<p>This mapping was compressed and saved for the package using the code:</p>

<pre><code class="R"># Not run: Only for building the package.
usethis::use_data(biomart_hsapiens)
tools::resaveRdaFiles(file.path(&quot;data&quot;), compress = &quot;auto&quot;)
tools::checkRdaFiles(file.path(&quot;data&quot;))
</code></pre>

</body>

</html>
